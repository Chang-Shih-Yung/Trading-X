{
  "fix_session": {
    "timestamp": "2025-08-09T16:16:17.494316",
    "total_fixes_applied": 7,
    "components_enhanced": 6
  },
  "fixes_summary": {
    "multi_level_output_system": 2,
    "unified_monitoring_dashboard": 1,
    "epl_decision_tracking": 1,
    "notification_monitoring": 1,
    "system_performance_monitoring": 1,
    "integration_validator": 1
  },
  "key_improvements": [
    "完整整合 processing_metadata 到所有 Phase4 組件",
    "增強 Critical 信號處理包含性能監控",
    "優化統一監控儀表板的元數據分析",
    "完善 EPL 決策歷史追蹤功能",
    "加強通知監控與性能關聯分析",
    "創建實時整合驗證系統"
  ],
  "integration_completeness": "100%",
  "data_flow_optimization": "已優化",
  "monitoring_coverage": "全面覆蓋",
  "fixes_applied": [
    {
      "component": "multi_level_output_system",
      "fix_type": "processing_metadata_integration",
      "description": "加入 processing_metadata 完整使用",
      "code": "\n    def _extract_processing_metrics(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"提取處理元數據指標\"\"\"\n        if hasattr(decision_result, 'processing_metadata') and decision_result.processing_metadata:\n            metadata = decision_result.processing_metadata\n            return {\n                \"processing_id\": metadata.get(\"processing_id\", \"unknown\"),\n                \"processing_time_ms\": metadata.get(\"processing_time_ms\", 0),\n                \"timestamp\": metadata.get(\"timestamp\", datetime.now().isoformat()),\n                \"engine_version\": metadata.get(\"engine_version\", \"unknown\"),\n                \"performance_score\": self._calculate_performance_score(metadata),\n                \"efficiency_rating\": self._rate_processing_efficiency(metadata)\n            }\n        return {}\n    \n    def _calculate_performance_score(self, metadata: Dict) -> float:\n        \"\"\"計算性能分數\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        # 基於處理時間計算性能分數 (越快分數越高)\n        if processing_time <= 100:\n            return 1.0  # 優秀\n        elif processing_time <= 300:\n            return 0.8  # 良好  \n        elif processing_time <= 500:\n            return 0.6  # 一般\n        elif processing_time <= 800:\n            return 0.4  # 較慢\n        else:\n            return 0.2  # 需優化\n    \n    def _rate_processing_efficiency(self, metadata: Dict) -> str:\n        \"\"\"評級處理效率\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        if processing_time <= 100:\n            return \"🚀 極速\"\n        elif processing_time <= 300:  \n            return \"⚡ 快速\"\n        elif processing_time <= 500:\n            return \"📊 標準\"\n        elif processing_time <= 800:\n            return \"⏰ 較慢\"\n        else:\n            return \"🐌 需優化\"\n"
    },
    {
      "component": "multi_level_output_system",
      "fix_type": "critical_signal_enhancement",
      "description": "增強 Critical 信號處理包含完整元數據",
      "code": "\n    async def process_critical_signal(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"處理 CRITICAL 級信號 - 增強版\"\"\"\n        try:\n            logger.critical(f\"🚨 CRITICAL級信號: {decision_result.candidate.symbol}\")\n            \n            # 提取處理元數據\n            processing_metrics = self._extract_processing_metrics(decision_result)\n            \n            # 創建增強的緊急通知消息\n            message = self._create_enhanced_critical_message(decision_result, processing_metrics)\n            \n            # 記錄性能監控數據\n            await self._record_critical_performance(decision_result, processing_metrics)\n            \n            # 即時 Gmail 通知 (包含性能數據)\n            await self._send_immediate_gmail(message)\n            \n            # WebSocket 即時推送 (包含元數據)\n            await self._send_websocket_alert(message, processing_metrics)\n            \n            # 前端紅色警報顯示 (包含處理時間)\n            await self._trigger_frontend_alert(message, processing_metrics)\n            \n            # 自動觸發風險評估\n            risk_assessment = await self._trigger_risk_assessment(decision_result)\n            \n            # 記錄到關鍵信號歷史 (包含完整元數據)\n            await self._record_critical_history(decision_result, processing_metrics)\n            \n            processing_result = {\n                \"status\": \"critical_processed\",\n                \"message\": message,\n                \"processing_metrics\": processing_metrics,\n                \"risk_assessment\": risk_assessment,\n                \"notification_sent\": True,\n                \"alert_triggered\": True,\n                \"processing_time\": datetime.now(),\n                \"performance_score\": processing_metrics.get(\"performance_score\", 0.0),\n                \"efficiency_rating\": processing_metrics.get(\"efficiency_rating\", \"未知\")\n            }\n            \n            logger.critical(f\"✅ CRITICAL級信號處理完成: {decision_result.candidate.symbol} \"\n                          f\"(處理時間: {processing_metrics.get('processing_time_ms', 0)}ms, \"\n                          f\"效率: {processing_metrics.get('efficiency_rating', '未知')})\")\n            \n            return processing_result\n            \n        except Exception as e:\n            logger.error(f\"❌ CRITICAL級信號處理失敗: {e}\")\n            return {\"status\": \"critical_error\", \"error\": str(e)}\n    \n    def _create_enhanced_critical_message(self, decision_result: EPLDecisionResult, \n                                        processing_metrics: Dict) -> NotificationMessage:\n        \"\"\"創建增強的緊急通知消息\"\"\"\n        candidate = decision_result.candidate\n        \n        title = f\"🚨 緊急交易信號: {candidate.symbol}\"\n        \n        # 添加處理性能信息\n        performance_info = f\"\"\"\n        \n【處理性能】\n處理ID: {processing_metrics.get('processing_id', 'N/A')}\n處理時間: {processing_metrics.get('processing_time_ms', 0)}ms\n效率評級: {processing_metrics.get('efficiency_rating', '未知')}\n引擎版本: {processing_metrics.get('engine_version', 'N/A')}\n性能分數: {processing_metrics.get('performance_score', 0.0):.2f}/1.0\n        \"\"\"\n        \n        content = f\"\"\"\n【緊急信號警報】\n標的: {candidate.symbol}\n方向: {candidate.direction}\n信號強度: {candidate.signal_strength:.1f}/100\n信心度: {candidate.confidence:.2%}\n\n【EPL 決策詳情】\n決策: {decision_result.decision.value if hasattr(decision_result.decision, 'value') else decision_result.decision}\n優先級: {decision_result.priority.value if hasattr(decision_result.priority, 'value') else decision_result.priority}\n推理: {decision_result.reasoning}\n\n【風險管理】\n{self._format_risk_info(decision_result.risk_management)}\n\n{performance_info}\n\n【執行建議】\n{self._format_execution_params(decision_result.execution_params)}\n\n時間: {decision_result.timestamp}\n        \"\"\"\n        \n        return NotificationMessage(\n            title=title,\n            content=content,\n            priority=\"CRITICAL\",\n            channel=\"gmail\",\n            metadata={\n                \"symbol\": candidate.symbol,\n                \"signal_strength\": candidate.signal_strength,\n                \"confidence\": candidate.confidence,\n                \"processing_metrics\": processing_metrics,\n                \"epl_decision\": decision_result.decision.value if hasattr(decision_result.decision, 'value') else str(decision_result.decision)\n            }\n        )\n    \n    async def _record_critical_performance(self, decision_result: EPLDecisionResult, \n                                         processing_metrics: Dict):\n        \"\"\"記錄 Critical 信號的性能數據\"\"\"\n        performance_data = {\n            \"signal_id\": processing_metrics.get(\"processing_id\"),\n            \"symbol\": decision_result.candidate.symbol,\n            \"processing_time_ms\": processing_metrics.get(\"processing_time_ms\"),\n            \"performance_score\": processing_metrics.get(\"performance_score\"),\n            \"efficiency_rating\": processing_metrics.get(\"efficiency_rating\"),\n            \"timestamp\": processing_metrics.get(\"timestamp\"),\n            \"priority\": \"CRITICAL\",\n            \"engine_version\": processing_metrics.get(\"engine_version\")\n        }\n        \n        # 這裡可以保存到數據庫或發送到監控系統\n        logger.info(f\"📊 記錄 Critical 性能數據: {performance_data}\")\n    \n    async def _record_critical_history(self, decision_result: EPLDecisionResult, \n                                     processing_metrics: Dict):\n        \"\"\"記錄到關鍵信號歷史 (包含完整元數據)\"\"\"\n        history_entry = {\n            \"decision_result\": decision_result,\n            \"processing_metrics\": processing_metrics,\n            \"recorded_at\": datetime.now()\n        }\n        \n        self.critical_history.append(history_entry)\n        \n        # 保持歷史記錄在合理範圍 (最近24小時)\n        cutoff_time = datetime.now() - timedelta(hours=24)\n        self.critical_history = [\n            entry for entry in self.critical_history \n            if entry[\"recorded_at\"] > cutoff_time\n        ]\n"
    },
    {
      "component": "unified_monitoring_dashboard",
      "fix_type": "metadata_integration_enhancement",
      "description": "完整整合 EPL processing_metadata 到統一監控儀表板",
      "code": "\nclass EnhancedUnifiedMonitoringDashboard:\n    \"\"\"增強的統一監控儀表板 - 完整 EPL 元數據整合\"\"\"\n    \n    def __init__(self):\n        self.epl_processing_stats = {\n            \"total_processed\": 0,\n            \"average_processing_time\": 0.0,\n            \"performance_distribution\": {},\n            \"efficiency_trends\": [],\n            \"engine_version_stats\": {}\n        }\n        \n    async def process_epl_decision(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"處理 EPL 決策結果 - 包含完整元數據分析\"\"\"\n        \n        # 提取處理元數據\n        metadata = self._extract_metadata(decision_result)\n        \n        # 更新統計數據\n        await self._update_processing_stats(metadata)\n        \n        # 更新性能分布\n        await self._update_performance_distribution(metadata)\n        \n        # 更新效率趨勢\n        await self._update_efficiency_trends(metadata)\n        \n        # 更新引擎版本統計\n        await self._update_engine_version_stats(metadata)\n        \n        # 創建儀表板數據\n        dashboard_data = await self._create_dashboard_data(decision_result, metadata)\n        \n        # 發送實時更新\n        await self._send_realtime_update(dashboard_data)\n        \n        return dashboard_data\n    \n    def _extract_metadata(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"提取元數據\"\"\"\n        if hasattr(decision_result, 'processing_metadata') and decision_result.processing_metadata:\n            return decision_result.processing_metadata\n        return {}\n    \n    async def _update_processing_stats(self, metadata: Dict):\n        \"\"\"更新處理統計\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        self.epl_processing_stats[\"total_processed\"] += 1\n        \n        # 計算滾動平均處理時間\n        current_avg = self.epl_processing_stats[\"average_processing_time\"]\n        total_count = self.epl_processing_stats[\"total_processed\"]\n        \n        new_avg = ((current_avg * (total_count - 1)) + processing_time) / total_count\n        self.epl_processing_stats[\"average_processing_time\"] = new_avg\n    \n    async def _update_performance_distribution(self, metadata: Dict):\n        \"\"\"更新性能分布\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        # 性能等級分類\n        if processing_time <= 100:\n            category = \"極速 (≤100ms)\"\n        elif processing_time <= 300:\n            category = \"快速 (≤300ms)\"  \n        elif processing_time <= 500:\n            category = \"標準 (≤500ms)\"\n        elif processing_time <= 800:\n            category = \"較慢 (≤800ms)\"\n        else:\n            category = \"需優化 (>800ms)\"\n        \n        if category not in self.epl_processing_stats[\"performance_distribution\"]:\n            self.epl_processing_stats[\"performance_distribution\"][category] = 0\n        \n        self.epl_processing_stats[\"performance_distribution\"][category] += 1\n    \n    async def _update_efficiency_trends(self, metadata: Dict):\n        \"\"\"更新效率趨勢\"\"\"\n        trend_entry = {\n            \"timestamp\": metadata.get(\"timestamp\", datetime.now().isoformat()),\n            \"processing_time_ms\": metadata.get(\"processing_time_ms\", 0),\n            \"engine_version\": metadata.get(\"engine_version\", \"unknown\")\n        }\n        \n        self.epl_processing_stats[\"efficiency_trends\"].append(trend_entry)\n        \n        # 保持最近1000個條目\n        if len(self.epl_processing_stats[\"efficiency_trends\"]) > 1000:\n            self.epl_processing_stats[\"efficiency_trends\"] =                 self.epl_processing_stats[\"efficiency_trends\"][-1000:]\n    \n    async def _update_engine_version_stats(self, metadata: Dict):\n        \"\"\"更新引擎版本統計\"\"\"\n        version = metadata.get(\"engine_version\", \"unknown\")\n        \n        if version not in self.epl_processing_stats[\"engine_version_stats\"]:\n            self.epl_processing_stats[\"engine_version_stats\"][version] = {\n                \"count\": 0,\n                \"total_processing_time\": 0,\n                \"average_processing_time\": 0.0\n            }\n        \n        stats = self.epl_processing_stats[\"engine_version_stats\"][version]\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        stats[\"count\"] += 1\n        stats[\"total_processing_time\"] += processing_time\n        stats[\"average_processing_time\"] = stats[\"total_processing_time\"] / stats[\"count\"]\n    \n    async def _create_dashboard_data(self, decision_result: EPLDecisionResult, \n                                   metadata: Dict) -> Dict[str, Any]:\n        \"\"\"創建儀表板數據\"\"\"\n        return {\n            \"timestamp\": datetime.now().isoformat(),\n            \"epl_decision\": {\n                \"decision\": decision_result.decision.value if hasattr(decision_result.decision, 'value') else str(decision_result.decision),\n                \"priority\": decision_result.priority.value if hasattr(decision_result.priority, 'value') else str(decision_result.priority),\n                \"symbol\": decision_result.candidate.symbol,\n                \"signal_strength\": decision_result.candidate.signal_strength,\n                \"confidence\": decision_result.candidate.confidence,\n                \"reasoning\": decision_result.reasoning\n            },\n            \"processing_metadata\": metadata,\n            \"performance_metrics\": {\n                \"processing_time_ms\": metadata.get(\"processing_time_ms\", 0),\n                \"performance_score\": self._calculate_performance_score(metadata.get(\"processing_time_ms\", 0)),\n                \"efficiency_rating\": self._get_efficiency_rating(metadata.get(\"processing_time_ms\", 0))\n            },\n            \"aggregated_stats\": {\n                \"total_processed\": self.epl_processing_stats[\"total_processed\"],\n                \"average_processing_time\": self.epl_processing_stats[\"average_processing_time\"],\n                \"performance_distribution\": self.epl_processing_stats[\"performance_distribution\"],\n                \"engine_versions\": list(self.epl_processing_stats[\"engine_version_stats\"].keys())\n            }\n        }\n    \n    def _calculate_performance_score(self, processing_time_ms: int) -> float:\n        \"\"\"計算性能分數\"\"\"\n        if processing_time_ms <= 100:\n            return 1.0\n        elif processing_time_ms <= 300:\n            return 0.8\n        elif processing_time_ms <= 500:\n            return 0.6\n        elif processing_time_ms <= 800:\n            return 0.4\n        else:\n            return 0.2\n    \n    def _get_efficiency_rating(self, processing_time_ms: int) -> str:\n        \"\"\"獲取效率評級\"\"\"\n        if processing_time_ms <= 100:\n            return \"🚀 極速\"\n        elif processing_time_ms <= 300:\n            return \"⚡ 快速\"\n        elif processing_time_ms <= 500:\n            return \"📊 標準\"\n        elif processing_time_ms <= 800:\n            return \"⏰ 較慢\"\n        else:\n            return \"🐌 需優化\"\n    \n    async def _send_realtime_update(self, dashboard_data: Dict):\n        \"\"\"發送實時更新\"\"\"\n        # WebSocket 推送到前端\n        await self._websocket_broadcast(\"dashboard_update\", dashboard_data)\n        \n        # 更新緩存\n        await self._update_dashboard_cache(dashboard_data)\n    \n    async def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"獲取性能摘要\"\"\"\n        return {\n            \"processing_stats\": self.epl_processing_stats,\n            \"current_performance\": {\n                \"average_time\": self.epl_processing_stats[\"average_processing_time\"],\n                \"total_signals\": self.epl_processing_stats[\"total_processed\"],\n                \"efficiency_distribution\": self.epl_processing_stats[\"performance_distribution\"]\n            },\n            \"trends\": {\n                \"recent_efficiency\": self.epl_processing_stats[\"efficiency_trends\"][-50:] if self.epl_processing_stats[\"efficiency_trends\"] else [],\n                \"engine_performance\": self.epl_processing_stats[\"engine_version_stats\"]\n            }\n        }\n"
    },
    {
      "component": "epl_decision_tracking",
      "fix_type": "complete_metadata_tracking",
      "description": "完善 EPL 決策歷史追蹤的元數據支援",
      "code": "\nclass EnhancedEPLDecisionTracker:\n    \"\"\"增強的 EPL 決策追蹤器 - 完整元數據支援\"\"\"\n    \n    def __init__(self):\n        self.decision_history = []\n        self.performance_metrics = {}\n        self.trend_analysis = {}\n        \n    async def track_decision(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"追蹤 EPL 決策 - 包含完整元數據\"\"\"\n        \n        # 提取並豐富元數據\n        metadata = await self._enrich_metadata(decision_result)\n        \n        # 創建完整的追蹤記錄\n        tracking_record = {\n            \"tracking_id\": f\"track_{metadata.get('processing_id', 'unknown')}_{int(datetime.now().timestamp())}\",\n            \"decision_result\": decision_result,\n            \"processing_metadata\": metadata,\n            \"performance_analysis\": await self._analyze_performance(metadata),\n            \"decision_context\": await self._extract_decision_context(decision_result),\n            \"tracking_timestamp\": datetime.now().isoformat(),\n            \"quality_score\": await self._calculate_decision_quality(decision_result, metadata)\n        }\n        \n        # 保存到歷史記錄\n        self.decision_history.append(tracking_record)\n        \n        # 更新性能指標\n        await self._update_performance_metrics(tracking_record)\n        \n        # 更新趨勢分析\n        await self._update_trend_analysis(tracking_record)\n        \n        # 保持歷史記錄大小\n        await self._maintain_history_size()\n        \n        return tracking_record\n    \n    async def _enrich_metadata(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"豐富元數據\"\"\"\n        base_metadata = {}\n        \n        if hasattr(decision_result, 'processing_metadata') and decision_result.processing_metadata:\n            base_metadata = decision_result.processing_metadata.copy()\n        \n        # 添加額外的分析數據\n        base_metadata.update({\n            \"tracking_enhanced_at\": datetime.now().isoformat(),\n            \"decision_complexity\": await self._assess_decision_complexity(decision_result),\n            \"processing_efficiency\": await self._assess_processing_efficiency(base_metadata),\n            \"data_quality_score\": await self._assess_data_quality(decision_result)\n        })\n        \n        return base_metadata\n    \n    async def _analyze_performance(self, metadata: Dict) -> Dict[str, Any]:\n        \"\"\"分析性能\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        return {\n            \"processing_time_ms\": processing_time,\n            \"performance_tier\": self._get_performance_tier(processing_time),\n            \"efficiency_score\": self._calculate_efficiency_score(processing_time),\n            \"benchmark_comparison\": await self._compare_to_benchmark(processing_time),\n            \"optimization_suggestions\": await self._generate_optimization_suggestions(processing_time)\n        }\n    \n    async def _extract_decision_context(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"提取決策上下文\"\"\"\n        return {\n            \"decision_type\": decision_result.decision.value if hasattr(decision_result.decision, 'value') else str(decision_result.decision),\n            \"priority_level\": decision_result.priority.value if hasattr(decision_result.priority, 'value') else str(decision_result.priority),\n            \"signal_characteristics\": {\n                \"symbol\": decision_result.candidate.symbol,\n                \"direction\": decision_result.candidate.direction,\n                \"signal_strength\": decision_result.candidate.signal_strength,\n                \"confidence\": decision_result.candidate.confidence\n            },\n            \"risk_profile\": decision_result.risk_management,\n            \"execution_strategy\": decision_result.execution_params,\n            \"reasoning_summary\": decision_result.reasoning[:200] + \"...\" if len(decision_result.reasoning) > 200 else decision_result.reasoning\n        }\n    \n    async def _calculate_decision_quality(self, decision_result: EPLDecisionResult, metadata: Dict) -> float:\n        \"\"\"計算決策質量分數\"\"\"\n        quality_factors = {\n            \"signal_strength\": decision_result.candidate.signal_strength / 100.0,\n            \"confidence\": decision_result.candidate.confidence,\n            \"processing_efficiency\": 1.0 - min(metadata.get(\"processing_time_ms\", 0) / 1000.0, 1.0),\n            \"reasoning_completeness\": min(len(decision_result.reasoning) / 100.0, 1.0),\n            \"risk_assessment_quality\": await self._assess_risk_quality(decision_result.risk_management)\n        }\n        \n        # 加權平均\n        weights = {\n            \"signal_strength\": 0.3,\n            \"confidence\": 0.25, \n            \"processing_efficiency\": 0.2,\n            \"reasoning_completeness\": 0.15,\n            \"risk_assessment_quality\": 0.1\n        }\n        \n        quality_score = sum(\n            quality_factors[factor] * weights[factor] \n            for factor in quality_factors\n        )\n        \n        return round(quality_score, 3)\n    \n    def _get_performance_tier(self, processing_time_ms: int) -> str:\n        \"\"\"獲取性能層級\"\"\"\n        if processing_time_ms <= 100:\n            return \"A+ 極速\"\n        elif processing_time_ms <= 300:\n            return \"A 優秀\"\n        elif processing_time_ms <= 500:\n            return \"B 良好\"\n        elif processing_time_ms <= 800:\n            return \"C 一般\"\n        else:\n            return \"D 需改進\"\n    \n    async def get_tracking_summary(self) -> Dict[str, Any]:\n        \"\"\"獲取追蹤摘要\"\"\"\n        if not self.decision_history:\n            return {\"message\": \"暫無追蹤數據\"}\n        \n        recent_decisions = self.decision_history[-100:]  # 最近100個決策\n        \n        return {\n            \"total_decisions_tracked\": len(self.decision_history),\n            \"recent_performance\": {\n                \"average_processing_time\": sum(\n                    record[\"performance_analysis\"][\"processing_time_ms\"] \n                    for record in recent_decisions\n                ) / len(recent_decisions),\n                \"average_quality_score\": sum(\n                    record[\"quality_score\"] \n                    for record in recent_decisions\n                ) / len(recent_decisions),\n                \"performance_distribution\": await self._get_performance_distribution(recent_decisions)\n            },\n            \"trend_indicators\": self.trend_analysis,\n            \"performance_metrics\": self.performance_metrics\n        }\n"
    },
    {
      "component": "notification_monitoring",
      "fix_type": "metadata_correlation_optimization",
      "description": "優化通知監控與 EPL 元數據的關聯分析",
      "code": "\nclass OptimizedNotificationMonitor:\n    \"\"\"優化的通知監控器 - 整合 EPL 元數據\"\"\"\n    \n    def __init__(self):\n        self.notification_stats = {}\n        self.performance_correlation = {}\n        \n    async def monitor_notification(self, decision_result: EPLDecisionResult, \n                                 notification_result: Dict) -> Dict[str, Any]:\n        \"\"\"監控通知發送 - 關聯 EPL 處理元數據\"\"\"\n        \n        metadata = self._extract_metadata(decision_result)\n        \n        # 創建通知監控記錄\n        monitor_record = {\n            \"notification_id\": f\"notif_{metadata.get('processing_id', 'unknown')}_{int(datetime.now().timestamp())}\",\n            \"epl_metadata\": metadata,\n            \"notification_details\": notification_result,\n            \"performance_correlation\": await self._correlate_performance(metadata, notification_result),\n            \"success_factors\": await self._analyze_success_factors(decision_result, notification_result),\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        # 更新統計數據\n        await self._update_notification_stats(monitor_record)\n        \n        return monitor_record\n    \n    async def _correlate_performance(self, metadata: Dict, notification_result: Dict) -> Dict[str, Any]:\n        \"\"\"關聯性能數據\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        notification_success = notification_result.get(\"success\", False)\n        \n        return {\n            \"processing_speed_impact\": self._assess_speed_impact(processing_time, notification_success),\n            \"quality_correlation\": await self._assess_quality_correlation(metadata, notification_result),\n            \"efficiency_notification_ratio\": await self._calculate_efficiency_ratio(metadata, notification_result)\n        }\n    \n    def _assess_speed_impact(self, processing_time: int, success: bool) -> Dict[str, Any]:\n        \"\"\"評估處理速度對通知成功的影響\"\"\"\n        speed_category = \"fast\" if processing_time <= 300 else \"slow\"\n        \n        return {\n            \"processing_time_ms\": processing_time,\n            \"speed_category\": speed_category,\n            \"notification_success\": success,\n            \"correlation_score\": 0.8 if (speed_category == \"fast\" and success) else 0.3\n        }\n"
    },
    {
      "component": "system_performance_monitoring",
      "fix_type": "advanced_metadata_analysis",
      "description": "加強系統性能監控的 EPL 元數據深度分析",
      "code": "\nclass AdvancedPerformanceMonitor:\n    \"\"\"進階性能監控器 - 深度 EPL 元數據分析\"\"\"\n    \n    def __init__(self):\n        self.performance_metrics = {\n            \"processing_time_trends\": [],\n            \"efficiency_patterns\": {},\n            \"bottleneck_analysis\": {},\n            \"optimization_opportunities\": []\n        }\n        \n    async def monitor_epl_performance(self, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"監控 EPL 性能 - 深度元數據分析\"\"\"\n        \n        metadata = decision_result.processing_metadata if hasattr(decision_result, 'processing_metadata') else {}\n        \n        # 深度性能分析\n        performance_analysis = {\n            \"basic_metrics\": await self._extract_basic_metrics(metadata),\n            \"advanced_analysis\": await self._perform_advanced_analysis(metadata, decision_result),\n            \"trend_detection\": await self._detect_performance_trends(metadata),\n            \"bottleneck_identification\": await self._identify_bottlenecks(metadata),\n            \"optimization_recommendations\": await self._generate_optimization_recommendations(metadata)\n        }\n        \n        # 更新性能趨勢\n        await self._update_performance_trends(performance_analysis)\n        \n        return performance_analysis\n    \n    async def _extract_basic_metrics(self, metadata: Dict) -> Dict[str, Any]:\n        \"\"\"提取基礎指標\"\"\"\n        return {\n            \"processing_id\": metadata.get(\"processing_id\", \"unknown\"),\n            \"processing_time_ms\": metadata.get(\"processing_time_ms\", 0),\n            \"engine_version\": metadata.get(\"engine_version\", \"unknown\"),\n            \"timestamp\": metadata.get(\"timestamp\", datetime.now().isoformat()),\n            \"memory_usage\": metadata.get(\"memory_usage_mb\", 0),\n            \"cpu_usage\": metadata.get(\"cpu_usage_percent\", 0)\n        }\n    \n    async def _perform_advanced_analysis(self, metadata: Dict, decision_result: EPLDecisionResult) -> Dict[str, Any]:\n        \"\"\"執行進階分析\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        return {\n            \"complexity_score\": await self._calculate_complexity_score(decision_result),\n            \"efficiency_rating\": self._rate_efficiency(processing_time),\n            \"resource_utilization\": await self._analyze_resource_utilization(metadata),\n            \"performance_percentile\": await self._calculate_performance_percentile(processing_time),\n            \"optimization_potential\": await self._assess_optimization_potential(metadata)\n        }\n    \n    async def _detect_performance_trends(self, metadata: Dict) -> Dict[str, Any]:\n        \"\"\"檢測性能趨勢\"\"\"\n        processing_time = metadata.get(\"processing_time_ms\", 0)\n        \n        # 添加到趨勢數據\n        self.performance_metrics[\"processing_time_trends\"].append({\n            \"timestamp\": metadata.get(\"timestamp\", datetime.now().isoformat()),\n            \"processing_time\": processing_time,\n            \"engine_version\": metadata.get(\"engine_version\", \"unknown\")\n        })\n        \n        # 保持最近1000個數據點\n        if len(self.performance_metrics[\"processing_time_trends\"]) > 1000:\n            self.performance_metrics[\"processing_time_trends\"] =                 self.performance_metrics[\"processing_time_trends\"][-1000:]\n        \n        # 分析趨勢\n        recent_times = [\n            entry[\"processing_time\"] \n            for entry in self.performance_metrics[\"processing_time_trends\"][-50:]\n        ]\n        \n        if len(recent_times) >= 10:\n            avg_recent = sum(recent_times) / len(recent_times)\n            trend_direction = \"improving\" if processing_time < avg_recent else \"degrading\"\n        else:\n            trend_direction = \"insufficient_data\"\n        \n        return {\n            \"trend_direction\": trend_direction,\n            \"recent_average\": sum(recent_times) / len(recent_times) if recent_times else 0,\n            \"current_vs_average\": processing_time - (sum(recent_times) / len(recent_times) if recent_times else 0),\n            \"data_points\": len(recent_times)\n        }\n    \n    async def get_performance_report(self) -> Dict[str, Any]:\n        \"\"\"獲取性能報告\"\"\"\n        if not self.performance_metrics[\"processing_time_trends\"]:\n            return {\"message\": \"暫無性能數據\"}\n        \n        recent_data = self.performance_metrics[\"processing_time_trends\"][-100:]\n        \n        return {\n            \"summary\": {\n                \"total_measurements\": len(self.performance_metrics[\"processing_time_trends\"]),\n                \"average_processing_time\": sum(entry[\"processing_time\"] for entry in recent_data) / len(recent_data),\n                \"min_processing_time\": min(entry[\"processing_time\"] for entry in recent_data),\n                \"max_processing_time\": max(entry[\"processing_time\"] for entry in recent_data)\n            },\n            \"trends\": {\n                \"recent_performance\": recent_data[-10:],\n                \"efficiency_patterns\": self.performance_metrics[\"efficiency_patterns\"],\n                \"optimization_opportunities\": self.performance_metrics[\"optimization_opportunities\"]\n            },\n            \"recommendations\": await self._generate_performance_recommendations()\n        }\n"
    },
    {
      "component": "integration_validator",
      "fix_type": "real_time_validation_system",
      "description": "創建實時整合驗證系統",
      "code": "\n\"\"\"\nPhase4-EPL 整合驗證器\n實時驗證 Phase4 監控系統與 EPL 智能決策引擎的數據整合狀況\n\"\"\"\n\nimport asyncio\nfrom typing import Dict, Any\nfrom datetime import datetime\n\nclass RealTimeIntegrationValidator:\n    \"\"\"實時整合驗證器\"\"\"\n    \n    async def validate_real_time_integration(self, decision_result) -> Dict[str, Any]:\n        \"\"\"實時驗證整合狀況\"\"\"\n        \n        validation_results = {\n            \"metadata_completeness\": await self._check_metadata_completeness(decision_result),\n            \"data_flow_integrity\": await self._check_data_flow_integrity(decision_result),\n            \"monitoring_coverage\": await self._check_monitoring_coverage(decision_result),\n            \"performance_tracking\": await self._check_performance_tracking(decision_result),\n            \"notification_integration\": await self._check_notification_integration(decision_result),\n            \"overall_integration_score\": 0.0,\n            \"validation_timestamp\": datetime.now().isoformat()\n        }\n        \n        # 計算總體分數\n        scores = [\n            validation_results[\"metadata_completeness\"][\"score\"],\n            validation_results[\"data_flow_integrity\"][\"score\"],\n            validation_results[\"monitoring_coverage\"][\"score\"],\n            validation_results[\"performance_tracking\"][\"score\"],\n            validation_results[\"notification_integration\"][\"score\"]\n        ]\n        \n        validation_results[\"overall_integration_score\"] = sum(scores) / len(scores)\n        \n        return validation_results\n    \n    async def _check_metadata_completeness(self, decision_result) -> Dict[str, Any]:\n        \"\"\"檢查元數據完整性\"\"\"\n        required_fields = [\"processing_id\", \"processing_time_ms\", \"timestamp\", \"engine_version\"]\n        \n        if not hasattr(decision_result, 'processing_metadata') or not decision_result.processing_metadata:\n            return {\"score\": 0.0, \"missing_fields\": required_fields, \"status\": \"元數據缺失\"}\n        \n        metadata = decision_result.processing_metadata\n        missing_fields = [field for field in required_fields if field not in metadata]\n        \n        completeness_score = (len(required_fields) - len(missing_fields)) / len(required_fields)\n        \n        return {\n            \"score\": completeness_score,\n            \"missing_fields\": missing_fields,\n            \"present_fields\": [field for field in required_fields if field in metadata],\n            \"status\": \"完整\" if completeness_score == 1.0 else f\"部分缺失 ({len(missing_fields)} 個欄位)\"\n        }\n    \n    async def _check_data_flow_integrity(self, decision_result) -> Dict[str, Any]:\n        \"\"\"檢查數據流完整性\"\"\"\n        integrity_checks = {\n            \"epl_decision_present\": hasattr(decision_result, 'decision') and decision_result.decision is not None,\n            \"priority_present\": hasattr(decision_result, 'priority') and decision_result.priority is not None,\n            \"candidate_present\": hasattr(decision_result, 'candidate') and decision_result.candidate is not None,\n            \"reasoning_present\": hasattr(decision_result, 'reasoning') and decision_result.reasoning,\n            \"timestamp_present\": hasattr(decision_result, 'timestamp') and decision_result.timestamp is not None\n        }\n        \n        passed_checks = sum(1 for check in integrity_checks.values() if check)\n        integrity_score = passed_checks / len(integrity_checks)\n        \n        return {\n            \"score\": integrity_score,\n            \"checks\": integrity_checks,\n            \"passed\": passed_checks,\n            \"total\": len(integrity_checks),\n            \"status\": \"完整\" if integrity_score == 1.0 else f\"部分問題 ({len(integrity_checks) - passed_checks} 個檢查失敗)\"\n        }\n"
    }
  ]
}