#!/usr/bin/env python3
"""
üéØ Trading X - TradingViewÈ¢®Ê†ºÂ†±ÂëäÁîüÊàêÂô®
Á¨¨‰∫åÈöéÊÆµÔºöÂ∞àÊ•≠Á¥öÂõûÊ∏¨ÂàÜÊûêÂ†±Âëä
Ê®°Êì¨TradingViewÁ≠ñÁï•Ê∏¨Ë©¶Âô®ÁöÑÂ†±ÂëäÊ†ºÂºèÂíåÊåáÊ®ô
"""

import asyncio
import logging
import json
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from pathlib import Path
import math
from dataclasses import dataclass, asdict
import sys

# Ê∑ªÂä†È†ÖÁõÆË∑ØÂæë
project_root = Path(__file__).parent
sys.path.append(str(project_root))

from historical_data_extension import HistoricalDataExtension
from multiframe_backtest_engine import MultiTimeframeBacktestEngine

logger = logging.getLogger(__name__)

@dataclass
class PerformanceMetrics:
    """TradingViewÈ¢®Ê†ºÁöÑÁ∏æÊïàÊåáÊ®ô"""
    # Âü∫Êú¨Á∏æÊïà
    net_profit: float
    net_profit_percent: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    
    # Êî∂ÁõäÊåáÊ®ô
    gross_profit: float
    gross_loss: float
    profit_factor: float
    max_runup: float
    max_drawdown: float
    
    # Âπ≥ÂùáÂÄº
    avg_trade: float
    avg_winning_trade: float
    avg_losing_trade: float
    avg_bars_in_trade: float
    
    # ÈÄ£Á∫åÊÄß
    max_consecutive_wins: int
    max_consecutive_losses: int
    
    # È¢®Èö™ÊåáÊ®ô
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float
    
    # ÊúüÊúõÂÄº
    expectancy: float
    sqn: float  # System Quality Number

@dataclass
class TradeRecord:
    """‰∫§ÊòìË®òÈåÑ"""
    entry_time: datetime
    exit_time: datetime
    entry_price: float
    exit_price: float
    quantity: float
    trade_type: str  # 'long' or 'short'
    profit_loss: float
    profit_loss_percent: float
    bars_in_trade: int
    signal_type: str
    mae: float  # Maximum Adverse Excursion
    mfe: float  # Maximum Favorable Excursion

class TradingViewStyleReportGenerator:
    """TradingViewÈ¢®Ê†ºÂ†±ÂëäÁîüÊàêÂô®"""
    
    def __init__(self):
        self.data_extension = None
        self.backtest_engine = None
        
    async def __aenter__(self):
        """Áï∞Ê≠•ÂàùÂßãÂåñ"""
        self.data_extension = await HistoricalDataExtension().__aenter__()
        self.backtest_engine = await MultiTimeframeBacktestEngine().__aenter__()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Ê∏ÖÁêÜË≥áÊ∫ê"""
        if self.data_extension:
            await self.data_extension.__aexit__(exc_type, exc_val, exc_tb)
        if self.backtest_engine:
            await self.backtest_engine.__aexit__(exc_type, exc_val, exc_tb)
    
    def calculate_mae_mfe(self, entry_price: float, exit_price: float, 
                         high_prices: List[float], low_prices: List[float], 
                         trade_type: str) -> Tuple[float, float]:
        """Ë®àÁÆóÊúÄÂ§ß‰∏çÂà©ÂÅèÁßª(MAE)ÂíåÊúÄÂ§ßÊúâÂà©ÂÅèÁßª(MFE)"""
        if trade_type.lower() == 'long':
            # Â§öÈ†≠‰∫§Êòì
            mae = min([(low - entry_price) / entry_price for low in low_prices])
            mfe = max([(high - entry_price) / entry_price for high in high_prices])
        else:
            # Á©∫È†≠‰∫§Êòì
            mae = max([(high - entry_price) / entry_price for high in high_prices])
            mfe = min([(low - entry_price) / entry_price for low in low_prices])
        
        return mae, mfe
    
    async def generate_detailed_trade_records(self, symbol: str, timeframe: str, 
                                            days_back: int = 30) -> List[TradeRecord]:
        """ÁîüÊàêË©≥Á¥∞ÁöÑ‰∫§ÊòìË®òÈåÑ"""
        logger.info(f"üìä ÁîüÊàê {symbol} {timeframe} Ë©≥Á¥∞‰∫§ÊòìË®òÈåÑ")
        
        # Áç≤ÂèñÊ≠∑Âè≤Êï∏Êìö
        historical_data = await self.data_extension.fetch_extended_historical_data(
            symbol=symbol, interval=timeframe, days_back=days_back
        )
        
        if not historical_data:
            return []
        
        df = self.data_extension.convert_to_dataframe(historical_data)
        df['symbol'] = symbol
        
        # ÁîüÊàê‰∫§Êòì‰ø°Ëôü
        signals = self.backtest_engine.generate_signals_from_indicators(df)
        
        trade_records = []
        
        # ÂÅáË®≠Âõ∫ÂÆöÊåÅÊúâÊúüÈñì
        holding_periods = {
            "1m": 60,    # 1Â∞èÊôÇ
            "5m": 12,    # 1Â∞èÊôÇ  
            "15m": 4,    # 1Â∞èÊôÇ
            "1h": 24,    # 1Â§©
            "4h": 6      # 1Â§©
        }
        
        holding_period = holding_periods.get(timeframe, 60)
        
        for signal in signals:
            try:
                entry_time = signal['timestamp']
                entry_price = signal['entry_price']
                
                # ÊâæÂà∞ÈÄÄÂá∫ÊôÇÈñìÂíåÂÉπÊ†º
                entry_idx = df.index.get_loc(entry_time)
                exit_idx = min(entry_idx + holding_period, len(df) - 1)
                
                if exit_idx >= len(df):
                    continue
                
                exit_time = df.index[exit_idx]
                exit_price = df.iloc[exit_idx]['close']
                
                # Á¢∫ÂÆö‰∫§ÊòìÈ°ûÂûã
                trade_type = 'long' if 'BUY' in signal['signal_type'] else 'short'
                
                # Ë®àÁÆóÁõàËôß
                if trade_type == 'long':
                    profit_loss = exit_price - entry_price
                    profit_loss_percent = (exit_price - entry_price) / entry_price
                else:
                    profit_loss = entry_price - exit_price
                    profit_loss_percent = (entry_price - exit_price) / entry_price
                
                # Áç≤ÂèñÊåÅÊúâÊúüÈñìÁöÑÈ´ò‰ΩéÈªû
                period_data = df.iloc[entry_idx:exit_idx+1]
                high_prices = period_data['high'].tolist()
                low_prices = period_data['low'].tolist()
                
                # Ë®àÁÆóMAEÂíåMFE
                mae, mfe = self.calculate_mae_mfe(
                    entry_price, exit_price, high_prices, low_prices, trade_type
                )
                
                trade_record = TradeRecord(
                    entry_time=entry_time,
                    exit_time=exit_time,
                    entry_price=entry_price,
                    exit_price=exit_price,
                    quantity=1.0,  # ÂÅáË®≠Âõ∫ÂÆöÊï∏Èáè
                    trade_type=trade_type,
                    profit_loss=profit_loss,
                    profit_loss_percent=profit_loss_percent,
                    bars_in_trade=exit_idx - entry_idx,
                    signal_type=signal['signal_type'],
                    mae=mae,
                    mfe=mfe
                )
                
                trade_records.append(trade_record)
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è ËôïÁêÜ‰ø°ËôüÂ§±Êïó: {e}")
                continue
        
        logger.info(f"‚úÖ ÁîüÊàê {len(trade_records)} Á≠Ü‰∫§ÊòìË®òÈåÑ")
        return trade_records
    
    def calculate_performance_metrics(self, trade_records: List[TradeRecord], 
                                    initial_capital: float = 10000) -> PerformanceMetrics:
        """Ë®àÁÆóTradingViewÈ¢®Ê†ºÁöÑÁ∏æÊïàÊåáÊ®ô"""
        if not trade_records:
            return PerformanceMetrics(
                net_profit=0, net_profit_percent=0, total_trades=0,
                winning_trades=0, losing_trades=0, win_rate=0,
                gross_profit=0, gross_loss=0, profit_factor=0,
                max_runup=0, max_drawdown=0,
                avg_trade=0, avg_winning_trade=0, avg_losing_trade=0,
                avg_bars_in_trade=0, max_consecutive_wins=0, max_consecutive_losses=0,
                sharpe_ratio=0, sortino_ratio=0, calmar_ratio=0,
                expectancy=0, sqn=0
            )
        
        # Âü∫Êú¨Áµ±Ë®à
        profits = [trade.profit_loss for trade in trade_records]
        winning_trades = [trade for trade in trade_records if trade.profit_loss > 0]
        losing_trades = [trade for trade in trade_records if trade.profit_loss < 0]
        
        total_trades = len(trade_records)
        winning_count = len(winning_trades)
        losing_count = len(losing_trades)
        win_rate = winning_count / total_trades if total_trades > 0 else 0
        
        # ÁõàËôßË®àÁÆó
        gross_profit = sum([trade.profit_loss for trade in winning_trades])
        gross_loss = abs(sum([trade.profit_loss for trade in losing_trades]))
        net_profit = gross_profit - gross_loss
        net_profit_percent = (net_profit / initial_capital) * 100
        
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        # Âπ≥ÂùáÂÄº
        avg_trade = net_profit / total_trades if total_trades > 0 else 0
        avg_winning_trade = gross_profit / winning_count if winning_count > 0 else 0
        avg_losing_trade = -gross_loss / losing_count if losing_count > 0 else 0
        avg_bars_in_trade = sum([trade.bars_in_trade for trade in trade_records]) / total_trades if total_trades > 0 else 0
        
        # Ë®àÁÆóË≥áÈáëÊõ≤Á∑öÂíåÂõûÊí§
        capital_curve = [initial_capital]
        for trade in trade_records:
            capital_curve.append(capital_curve[-1] + trade.profit_loss)
        
        # ÊúÄÂ§ßÂõûÊí§ÂíåÊúÄÂ§ß‰∏äÂçá
        peak = initial_capital
        max_drawdown = 0
        max_runup = 0
        
        for capital in capital_curve[1:]:
            if capital > peak:
                max_runup = max(max_runup, capital - peak)
                peak = capital
            else:
                drawdown = peak - capital
                max_drawdown = max(max_drawdown, drawdown)
        
        max_drawdown_percent = (max_drawdown / initial_capital) * 100
        max_runup_percent = (max_runup / initial_capital) * 100
        
        # ÈÄ£Á∫åÂãùË≤†Ê¨°Êï∏
        consecutive_wins = 0
        consecutive_losses = 0
        max_consecutive_wins = 0
        max_consecutive_losses = 0
        
        for trade in trade_records:
            if trade.profit_loss > 0:
                consecutive_wins += 1
                consecutive_losses = 0
                max_consecutive_wins = max(max_consecutive_wins, consecutive_wins)
            else:
                consecutive_losses += 1
                consecutive_wins = 0
                max_consecutive_losses = max(max_consecutive_losses, consecutive_losses)
        
        # È¢®Èö™ÊåáÊ®ô
        returns = [trade.profit_loss / initial_capital for trade in trade_records]
        
        if len(returns) > 1:
            returns_std = np.std(returns)
            avg_return = np.mean(returns)
            
            # Sharpe Ratio (ÂÅáË®≠ÁÑ°È¢®Èö™Âà©ÁéáÁÇ∫0)
            sharpe_ratio = avg_return / returns_std if returns_std > 0 else 0
            
            # Sortino Ratio (Âè™ËÄÉÊÖÆ‰∏ãË°åÈ¢®Èö™)
            negative_returns = [r for r in returns if r < 0]
            downside_std = np.std(negative_returns) if negative_returns else 0
            sortino_ratio = avg_return / downside_std if downside_std > 0 else 0
            
            # Calmar Ratio
            annual_return = avg_return * 252 * 24 * 60  # ÂÅáË®≠1ÂàÜÈêòÊï∏Êìö
            calmar_ratio = annual_return / (max_drawdown_percent / 100) if max_drawdown_percent > 0 else 0
        else:
            sharpe_ratio = sortino_ratio = calmar_ratio = 0
        
        # ÊúüÊúõÂÄºÂíåSQN
        expectancy = avg_trade
        
        # System Quality Number (Van Tharp)
        if len(profits) > 1:
            sqn = (np.mean(profits) / np.std(profits)) * math.sqrt(len(profits))
        else:
            sqn = 0
        
        return PerformanceMetrics(
            net_profit=net_profit,
            net_profit_percent=net_profit_percent,
            total_trades=total_trades,
            winning_trades=winning_count,
            losing_trades=losing_count,
            win_rate=win_rate,
            gross_profit=gross_profit,
            gross_loss=gross_loss,
            profit_factor=profit_factor,
            max_runup=max_runup_percent,
            max_drawdown=max_drawdown_percent,
            avg_trade=avg_trade,
            avg_winning_trade=avg_winning_trade,
            avg_losing_trade=avg_losing_trade,
            avg_bars_in_trade=avg_bars_in_trade,
            max_consecutive_wins=max_consecutive_wins,
            max_consecutive_losses=max_consecutive_losses,
            sharpe_ratio=sharpe_ratio,
            sortino_ratio=sortino_ratio,
            calmar_ratio=calmar_ratio,
            expectancy=expectancy,
            sqn=sqn
        )
    
    def generate_tradingview_style_report(self, symbol: str, timeframe: str, 
                                        trade_records: List[TradeRecord],
                                        performance_metrics: PerformanceMetrics) -> Dict[str, Any]:
        """ÁîüÊàêTradingViewÈ¢®Ê†ºÁöÑÂÆåÊï¥Â†±Âëä"""
        
        # ÊÄßËÉΩÂàÜÈ°û
        def classify_performance(metrics: PerformanceMetrics) -> str:
            score = 0
            
            # ÂãùÁéáË©ïÂàÜ (0-30ÂàÜ)
            if metrics.win_rate >= 0.7:
                score += 30
            elif metrics.win_rate >= 0.6:
                score += 25
            elif metrics.win_rate >= 0.5:
                score += 20
            elif metrics.win_rate >= 0.4:
                score += 15
            else:
                score += 10
            
            # ÁõàËôßÊØîË©ïÂàÜ (0-25ÂàÜ)
            if metrics.profit_factor >= 2.0:
                score += 25
            elif metrics.profit_factor >= 1.5:
                score += 20
            elif metrics.profit_factor >= 1.2:
                score += 15
            elif metrics.profit_factor >= 1.0:
                score += 10
            else:
                score += 5
            
            # Sharpe RatioË©ïÂàÜ (0-20ÂàÜ)
            if metrics.sharpe_ratio >= 1.5:
                score += 20
            elif metrics.sharpe_ratio >= 1.0:
                score += 15
            elif metrics.sharpe_ratio >= 0.5:
                score += 10
            else:
                score += 5
            
            # ÊúÄÂ§ßÂõûÊí§Ë©ïÂàÜ (0-25ÂàÜ)
            if metrics.max_drawdown <= 5:
                score += 25
            elif metrics.max_drawdown <= 10:
                score += 20
            elif metrics.max_drawdown <= 15:
                score += 15
            elif metrics.max_drawdown <= 25:
                score += 10
            else:
                score += 5
            
            if score >= 85:
                return "üèÜ Excellent"
            elif score >= 70:
                return "‚úÖ Good"
            elif score >= 55:
                return "‚ö° Average"
            elif score >= 40:
                return "‚ö†Ô∏è Below Average"
            else:
                return "‚ùå Poor"
        
        performance_rating = classify_performance(performance_metrics)
        
        # ÁîüÊàêÊúàÂ∫¶Áµ±Ë®à
        monthly_stats = {}
        if trade_records:
            df_trades = pd.DataFrame([asdict(trade) for trade in trade_records])
            df_trades['entry_time'] = pd.to_datetime(df_trades['entry_time'])
            df_trades['month'] = df_trades['entry_time'].dt.to_period('M')
            
            for month, group in df_trades.groupby('month'):
                monthly_profit = group['profit_loss'].sum()
                monthly_trades = len(group)
                monthly_wins = len(group[group['profit_loss'] > 0])
                monthly_win_rate = monthly_wins / monthly_trades if monthly_trades > 0 else 0
                
                monthly_stats[str(month)] = {
                    "trades": monthly_trades,
                    "profit_loss": monthly_profit,
                    "win_rate": monthly_win_rate,
                    "avg_trade": monthly_profit / monthly_trades if monthly_trades > 0 else 0
                }
        
        report = {
            "strategy_overview": {
                "strategy_name": f"Trading-X Multi-Indicator Strategy",
                "symbol": symbol,
                "timeframe": timeframe,
                "backtest_period": {
                    "start": trade_records[0].entry_time.isoformat() if trade_records else None,
                    "end": trade_records[-1].exit_time.isoformat() if trade_records else None,
                    "total_days": (trade_records[-1].exit_time - trade_records[0].entry_time).days if trade_records else 0
                },
                "performance_rating": performance_rating
            },
            
            "performance_summary": {
                "net_profit": f"${performance_metrics.net_profit:,.2f}",
                "net_profit_percent": f"{performance_metrics.net_profit_percent:+.2f}%",
                "total_trades": performance_metrics.total_trades,
                "win_rate": f"{performance_metrics.win_rate:.1%}",
                "profit_factor": f"{performance_metrics.profit_factor:.2f}",
                "max_drawdown": f"{performance_metrics.max_drawdown:.2f}%",
                "sharpe_ratio": f"{performance_metrics.sharpe_ratio:.2f}",
                "expectancy": f"${performance_metrics.expectancy:.2f}"
            },
            
            "detailed_statistics": asdict(performance_metrics),
            
            "trade_distribution": {
                "winning_trades": performance_metrics.winning_trades,
                "losing_trades": performance_metrics.losing_trades,
                "largest_winning_trade": max([trade.profit_loss for trade in trade_records], default=0),
                "largest_losing_trade": min([trade.profit_loss for trade in trade_records], default=0),
                "avg_winning_trade": f"${performance_metrics.avg_winning_trade:.2f}",
                "avg_losing_trade": f"${performance_metrics.avg_losing_trade:.2f}",
                "max_consecutive_wins": performance_metrics.max_consecutive_wins,
                "max_consecutive_losses": performance_metrics.max_consecutive_losses
            },
            
            "monthly_breakdown": monthly_stats,
            
            "risk_analysis": {
                "max_drawdown_details": {
                    "percentage": f"{performance_metrics.max_drawdown:.2f}%",
                    "rating": "Low Risk" if performance_metrics.max_drawdown < 10 else 
                             "Medium Risk" if performance_metrics.max_drawdown < 20 else "High Risk"
                },
                "volatility_metrics": {
                    "sharpe_ratio": performance_metrics.sharpe_ratio,
                    "sortino_ratio": performance_metrics.sortino_ratio,
                    "calmar_ratio": performance_metrics.calmar_ratio
                },
                "system_quality": {
                    "sqn_score": performance_metrics.sqn,
                    "sqn_rating": "Excellent" if performance_metrics.sqn > 3.0 else
                                 "Good" if performance_metrics.sqn > 2.0 else
                                 "Average" if performance_metrics.sqn > 1.0 else "Poor"
                }
            },
            
            "recommendations": self._generate_strategy_recommendations(performance_metrics),
            
            "report_metadata": {
                "generated_at": datetime.now().isoformat(),
                "report_version": "tradingview_style_v1.0",
                "total_trades_analyzed": len(trade_records)
            }
        }
        
        return report
    
    def _generate_strategy_recommendations(self, metrics: PerformanceMetrics) -> List[str]:
        """ÁîüÊàêÁ≠ñÁï•ÊîπÈÄ≤Âª∫Ë≠∞"""
        recommendations = []
        
        # ÂãùÁéáÂª∫Ë≠∞
        if metrics.win_rate < 0.5:
            recommendations.append("‚ö†Ô∏è ÂãùÁéáÂÅè‰ΩéÔºåÂª∫Ë≠∞Ë™øÊï¥ÈÄ≤Â†¥Ê¢ù‰ª∂ÊàñÂ¢ûÂä†ÈÅéÊøæÂô®")
        elif metrics.win_rate > 0.8:
            recommendations.append("‚ö° ÂãùÁéáÈÅéÈ´òÔºåÂèØËÉΩ‰ø°ËôüÈ†ªÁéáÈÅé‰ΩéÔºåËÄÉÊÖÆÊîæÂØ¨ÈÄ≤Â†¥Ê¢ù‰ª∂")
        
        # ÁõàËôßÊØîÂª∫Ë≠∞
        if metrics.profit_factor < 1.2:
            recommendations.append("üìà ÁõàËôßÊØîÂÅè‰ΩéÔºåÂª∫Ë≠∞ÂÑ™ÂåñÊ≠¢ÁõàÊ≠¢ÊêçÁ≠ñÁï•")
        elif metrics.profit_factor > 3.0:
            recommendations.append("üéØ ÂÑ™ÁßÄÁöÑÁõàËôßÊØîÔºåÂèØËÄÉÊÖÆÂ¢ûÂä†ÂÄâ‰ΩçÊàñ‰ø°ËôüÈ†ªÁéá")
        
        # ÂõûÊí§Âª∫Ë≠∞
        if metrics.max_drawdown > 20:
            recommendations.append("üõ°Ô∏è ÊúÄÂ§ßÂõûÊí§ÈÅéÂ§ßÔºåÂº∑ÁÉàÂª∫Ë≠∞Âä†Âº∑È¢®Èö™ÊéßÂà∂")
        elif metrics.max_drawdown < 5:
            recommendations.append("üíé ÂõûÊí§ÊéßÂà∂ÂÑ™ÁßÄÔºåÂèØËÄÉÊÖÆÈÅ©Â∫¶Â¢ûÂä†È¢®Èö™Êö¥Èú≤")
        
        # SharpeÊØîÁéáÂª∫Ë≠∞
        if metrics.sharpe_ratio < 0.5:
            recommendations.append("üìä Â§èÊôÆÊØîÁéáÂÅè‰ΩéÔºåÂª∫Ë≠∞Âπ≥Ë°°Êî∂ÁõäËàáÈ¢®Èö™")
        elif metrics.sharpe_ratio > 2.0:
            recommendations.append("üèÜ ÂÑ™ÁßÄÁöÑÈ¢®Èö™Ë™øÊï¥Êî∂ÁõäÔºåÁ≠ñÁï•Ë°®ÁèæÂçìË∂ä")
        
        # ‰∫§ÊòìÈ†ªÁéáÂª∫Ë≠∞
        if metrics.total_trades < 20:
            recommendations.append("üîÑ ‰∫§ÊòìÊ¨°Êï∏ÂÅèÂ∞ëÔºåÁµ±Ë®àÊÑèÁæ©ÊúâÈôêÔºåÂª∫Ë≠∞Â¢ûÂä†Ê®£Êú¨Êï∏")
        elif metrics.total_trades > 500:
            recommendations.append("‚ö° ‰∫§ÊòìÈ†ªÁéáÂæàÈ´òÔºåÊ≥®ÊÑè‰∫§ÊòìÊàêÊú¨ÁöÑÂΩ±Èüø")
        
        # ÈÄ£Á∫åËôßÊêçÂª∫Ë≠∞
        if metrics.max_consecutive_losses > 10:
            recommendations.append("üö® ÈÄ£Á∫åËôßÊêçÊ¨°Êï∏ÈÅéÂ§öÔºåÂª∫Ë≠∞Â¢ûÂä†ÂÅúÊêçÊ©üÂà∂")
        
        if not recommendations:
            recommendations.append("‚ú® Á≠ñÁï•Ë°®ÁèæÂùáË°°ÔºåÂª∫Ë≠∞ÊåÅÁ∫åÁõ£Êéß‰∏¶ÂÆöÊúüÂÑ™Âåñ")
        
        return recommendations
    
    async def generate_comprehensive_report(self, symbol: str = "BTCUSDT", 
                                          timeframe: str = "1m", 
                                          days_back: int = 7) -> Dict[str, Any]:
        """ÁîüÊàêÂÆåÊï¥ÁöÑTradingViewÈ¢®Ê†ºÂ†±Âëä"""
        logger.info(f"üìä ÁîüÊàê {symbol} {timeframe} ÂÆåÊï¥Â†±Âëä")
        
        # ÁîüÊàê‰∫§ÊòìË®òÈåÑ
        trade_records = await self.generate_detailed_trade_records(symbol, timeframe, days_back)
        
        if not trade_records:
            logger.warning("‚ö†Ô∏è ÁÑ°‰∫§ÊòìË®òÈåÑÔºåÁÑ°Ê≥ïÁîüÊàêÂ†±Âëä")
            return {"error": "No trade records generated"}
        
        # Ë®àÁÆóÁ∏æÊïàÊåáÊ®ô
        performance_metrics = self.calculate_performance_metrics(trade_records)
        
        # ÁîüÊàêÂÆåÊï¥Â†±Âëä
        report = self.generate_tradingview_style_report(symbol, timeframe, trade_records, performance_metrics)
        
        logger.info(f"‚úÖ Â†±ÂëäÁîüÊàêÂÆåÊàê: {len(trade_records)} Á≠Ü‰∫§ÊòìÔºå"
                   f"ÂãùÁéá {performance_metrics.win_rate:.1%}Ôºå"
                   f"ÁõàËôßÊØî {performance_metrics.profit_factor:.2f}")
        
        return report


async def test_tradingview_report():
    """Ê∏¨Ë©¶TradingViewÈ¢®Ê†ºÂ†±ÂëäÁîüÊàê"""
    logger.info("üß™ ÈñãÂßãÊ∏¨Ë©¶TradingViewÈ¢®Ê†ºÂ†±ÂëäÁîüÊàêÂô®")
    
    async with TradingViewStyleReportGenerator() as report_gen:
        # ÁîüÊàêÊ∏¨Ë©¶Â†±Âëä
        report = await report_gen.generate_comprehensive_report(
            symbol="BTCUSDT",
            timeframe="5m", 
            days_back=7
        )
        
        if "error" in report:
            logger.error(f"‚ùå Â†±ÂëäÁîüÊàêÂ§±Êïó: {report['error']}")
            return None
        
        # Ëº∏Âá∫Â†±ÂëäÊëòË¶Å
        overview = report["strategy_overview"]
        performance = report["performance_summary"]
        
        logger.info(f"üìä Á≠ñÁï•Ê¶ÇË¶Ω:")
        logger.info(f"   - ‰∫§ÊòìÂ∞ç: {overview['symbol']} {overview['timeframe']}")
        logger.info(f"   - ÂõûÊ∏¨ÊúüÈñì: {overview['backtest_period']['total_days']} Â§©")
        logger.info(f"   - Ë°®ÁèæË©ïÁ¥ö: {overview['performance_rating']}")
        
        logger.info(f"üìà Á∏æÊïàÊëòË¶Å:")
        logger.info(f"   - Ê∑®Âà©ÊΩ§: {performance['net_profit']}")
        logger.info(f"   - ÂãùÁéá: {performance['win_rate']}")
        logger.info(f"   - ÁõàËôßÊØî: {performance['profit_factor']}")
        logger.info(f"   - ÊúÄÂ§ßÂõûÊí§: {performance['max_drawdown']}")
        logger.info(f"   - Â§èÊôÆÊØîÁéá: {performance['sharpe_ratio']}")
        
        # È°ØÁ§∫Âª∫Ë≠∞
        logger.info(f"üí° Á≠ñÁï•Âª∫Ë≠∞:")
        for i, rec in enumerate(report["recommendations"][:3], 1):
            logger.info(f"   {i}. {rec}")
        
        # ‰øùÂ≠òÂ†±ÂëäÂà∞Ëá®ÊôÇÊ™îÊ°à
        output_file = Path(__file__).parent / "tradingview_report_temp.json"
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"üìÅ Â†±ÂëäÂ∑≤‰øùÂ≠òÂà∞: {output_file}")
        return report


if __name__ == "__main__":
    # Ë®≠ÁΩÆÊó•Ë™å
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    
    # ÈÅãË°åÊ∏¨Ë©¶
    asyncio.run(test_tradingview_report())
